#!/usr/bin/env node
/**
 * Module dependencies.
 */
var app = require('../app')
var debug = require('debug')('teamcontrol-reader:server')
var http = require('http')
var Terminal = require('../models/terminal')
var request = require('request')
appHelper = require('../helpers/application_helper')
var theReaderClass = require('../models/reader/rfidReader')
var StatusInfo = require('../models/statusInfo')
/**
 * Get port from environment and store in Express.
 */
var port = normalizePort(process.env.PORT || '4000')
app.set('port', port)
/**
 * Create HTTP server.
 */
var server = http.createServer(app)
/**
 * Listen on provided port, on all network interfaces.
 */
var io = require('socket.io').listen(server)
server.listen(port, '0.0.0.0')
server.on('error', onError)
server.on('listening', onListening)
/**
 * Normalize a port into a number, string, or false.
 */
function normalizePort(val) {
  var port = parseInt(val, 10)
  if (isNaN(port)) {
    // named pipe
    return val
  }
  if (port >= 0) {
    // port number
    return port
  }
  return false
}
/**
 * Event listener for HTTP server "error" event.
 */
function onError(error) {
  if (error.syscall !== 'listen') {
    throw error
  }
  var bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port
  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges')
      process.exit(1)
      break
    case 'EADDRINUSE':
      console.error(bind + ' is already in use')
      process.exit(1)
      break
    default:
      throw error
  }
}
/**
 * Event listener for HTTP server "listening" event.
 */
function onListening() {
  var addr = server.address()
  var bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port
  debug('Listening on ' + bind)
}

this.myTerminal = new Terminal()
var displayTimeout
var pingTimeout
var readerConnectTimeOut
var self = this
var lastConnectedClient
var displayTimeOutRunning = false
// Kommt ein neuer Client bekommt er den Aktuellen Status zu sehen
io.on('connection', function (socket) {
  if(self.myTerminal != null) {
    lastConnectedClient = socket
    socket.emit('terminalContent', self.myTerminal.generate_connection_info())
  }
})

visualizeScanInfo = function(scanInfo){

}

// Leitet den aktuellen Status an den Client weiter
visualizeStatusInfo = function(statusInfo) {
  clearTimeout(self.pingTimeout)
  if(lastConnectedClient != undefined){
    lastConnectedClient.emit('terminalContent', statusInfo)  
  }
  self.pingTimeout = setTimeout(function(){
    authenticationRequest(self.myTerminal.getMacAddress())
  }, 5 * 1000)
}


sendTagRequest = function(tagID, macAsString){
  that = this
  request_options = {
    url: 'http://10.99.99.104:3000/api/v1/event', // TODO WOHER?
    headers: {
      'X-Tc-Token': self.myTerminal.getMacAddress(),
      'Content-Type': 'application/json'
    },
    form: {
      id: tagID
    }
  }

  request.post(request_options, function(error, httpResponse, body){
    content = new StatusInfo()

    if(error){
      // Fehler bei der Übertragung. Selbes verhalten wie bei "default"?
      self.myTerminal.connectionError(error)
      content = self.myTerminal.generate_connection_info()
      return
    } else {
      if(httpResponse.statusCode >= 200 && httpResponse.statusCode < 300){
        content = httpResponse.body
          if(content['status']) {
          } else {
            content = JSON.parse(content)
          }
      }else{
        switch(httpResponse.statusCode){
          case 406: // tagID ist ungültig
          case 500: // tagID ist auch hier ungültig o.O?
          case 404: // Kein aktives Rennen
            content = httpResponse.body
            if(content['status']) {
            } else {
              content = JSON.parse(content)
            }
            break
          case 401: // Terminal nicht bekannt
            self.myTerminal.setAuthenticated(false)
            content = self.myTerminal.generate_connection_info()
            authenticationRequest(self.myTerminal.getMacAddress)
            return
          default: // Andere, nicht definierte, Antwort
            self.myTerminal.setConnected(false)
            content = self.myTerminal.generate_connection_info()
            authenticationRequest(self.myTerminal.getMacAddress)
            return
        }
      }
    }
    visualizeStatusInfo(content)
  })
}

authenticationRequest = function(macAsString) {
  request_options = {
    url: 'http://10.99.99.104:3000/api/v1/ping', // TODO WOHER?
    headers: {
      'X-Tc-Token': self.myTerminal.getMacAddress(),
      'Content-Type': 'application/json'
    }
  }

  request(request_options, function(error, httpResponse, body){
    if(!error && httpResponse.statusCode == 200){
      // Yeah die MAC-Adresse ist beim Server bekannt
      self.myTerminal.setAuthenticated(true)
      self.myTerminal.setConnected(true)
    } else if(!error && httpResponse.statusCode == 401) {
      // Die Mac-Adresse ist beim Server nicht bekannt
      self.myTerminal.setAuthenticated(false)
      self.myTerminal.setConnected(true)
    } else { 
      // Alles andere -> Fehler.
      self.myTerminal.setConnected(false)
    }
    visualizeStatusInfo(self.myTerminal.generate_connection_info())
  })
}


tryConnectTheReader = function(){
  if(self.readerConnectTimeOut != undefined) {
    clearInterval(self.readerConnectTimeOut)
  }
  if(self.myTerminal.getReaderRdy()) {
    visualizeStatusInfo(self.myTerminal.generate_connection_info())
  }else {
    self.theReader.open()
    self.readerConnectTimeOut = setInterval(tryConnectTheReader, 5*1000)
  }
}

var readerDataFunction = function(tagID){
  tagStatus = self.myTerminal.checkTagId(tagID)
  visualizeStatusInfo(tagStatus)
  if(tagStatus['status'] == 'info'){
    sendTagRequest(tagID)
  }
}

var readerCloseFunction = function(data){
  self.myTerminal.setReaderRdy(false)
  visualizeStatusInfo(self.myTerminal.generate_connection_info(data))
  tryConnectTheReader()
}

var readerRdyFunction = function(){
  self.myTerminal.setReaderRdy(true)
  clearInterval(self.readerConnectTimeOut)
  visualizeStatusInfo(self.myTerminal.generate_connection_info())
}


this.theReader = new theReaderClass(readerRdyFunction, readerDataFunction, readerCloseFunction)

appHelper.getMac(function(error, mac){
  self.myTerminal.setMacAddress(mac)
  self.pingTimeout = setTimeout(function(){
    authenticationRequest(self.myTerminal.getMacAddress())
  }, 5 * 1000)
  self.readerConnectTimeOut = setInterval(tryConnectTheReader, 1000)
})
